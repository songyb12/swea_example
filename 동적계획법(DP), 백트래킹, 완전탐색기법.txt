[알고리즘의 중요성]

예를 들면 숫자 배열 중에서 가장 '최대 합을 갖는 구간' 찾기 같은 경우, O(n3)짜리 알고리즘 하나를 쥐어짜서 divide&conquer로 만들면 O(n*logn) 정도의 복잡도로 만들 수도 있는데, 동적 계획법으로 더욱 쥐어짜면 O(n)으로 만들 수도 있다. 체감상 따지자면 몇만 개의 데이터 속에서 최대 구간을 찾으려면 O(n3)은 80000초 가량이 걸릴 수도 있는데 O(n)으로는 1초도 안 되어 나오기까지 한다. 


[동적계획법]
특정 범위까지의 값을 구하기 위해서 그것과 다른 범위까지의 값을 이용하여 효율적으로 값을 구하는 알고리즘 설계 기법이다.

앞에서 구했던 답을 뒤에서도 이용하고, 옆에서도 이용하고...엄밀히 말해 동적 계획법은 구체적인 알고리즘이라기보다는 문제해결 패러다임에 가깝다. 동적 계획법은 "어떤 문제를 풀기 위해 그 문제를 더 작은 문제의 연장선으로 생각하고, 과거에 구한 해를 활용하는" 방식의 알고리즘을 총칭한다. 

가장 흔하게 사용할 수 있는 것이 
모든 경우에 대한 배열을 선언하고
계산하는 경우에 그 답에 해당하는 배열을 수정하는 것.

예를 들어 피보나치 함수의 경우
피보나치 값의 중복 계산이 있을 수 있으므로
f(n)의 경우 a[n] 을 선언한 후, 각 경우에 대한 답을 a[n]에 작성해두는 것.


[백트래킹]
어떠 노드에서 출발하는 경로가 해결책으로 이어질 것 같지 않으면 그 경로를 제거
가치지기(Prunning)
불필요한 경로의 조기 차단
N! 가지의 경우의수를 가진 문제에 대해 백트레킹을 가하면 일반적으로 경우의 수가 감소
하지만 최악의 경우에는 여전히 지수함수 시간을 요하므로 처리 불가
모든 후보를 검사하지는 않음


[완전탐색 알고리즘]
깊이우선탐색[DFS]. 너비우선탐색[BFS]. 최선우선탐색. 3가지 경우가 있다.

[DFS]
재귀함수로 구현할 수 있으며, 재귀함수에 익숙하지 않다면 스택을 써서 할 수도 있다.사실 재귀가 코딩 분량도 적고 직관적이다

[BFS]
BFS는 큐를 써서 구현한다. 각 경우를 검사하면서 발생하는 새로운 경우를 큐에 집어넣고, 검사한 원소는 큐에서 뺀다. BFS의 장점은 DFS가 못 건드리는 문제를 풀 수 있는 것이지만, 공간 복잡도가 지수 스케일로 폭발하기 때문에 가지치기를 제대로 안하면 DFS보다 빨리 오버플로우에 다다를 수 있다.
