
// LIS (Longest Increasing Subsequence)
#include <cstdio>
// 1. DP O(n^2)
// DP : x번째 수를 마지막 원소로 가지는 lis의 길이 의 배열
// 각 원소들의 DP 값을 찾기 위해, 모든 원소를 한번씩 순회한다.
// 따라서 O(n^2)
#define loop1(i, x) for (int i = 0; i < x; i++)
int SolveWithDP(int* arr, int arr_length) {
	int dp[1000];
	loop1(i, 1000) dp[i] = 0;
	int res = 0;
	for (int i = 0; i<arr_length; i++) {
		if (dp[i] == 0) dp[i] = 1;
		for (int j = 0; j<i; j++)
			if (arr[i] > arr[j])
				if (dp[i] < dp[j] + 1) {
					dp[i] = dp[j] + 1;
					if (res < dp[i]) res = dp[i];
				}
	}
	return res;
}

// 2. Lower_Bound	O(NlogN)
// Lower_Bound
// 선형구조의 부분 탐색법인 이분탐색의 경우는 찾고자 하는 값이 없으면 탐색에 실패
// Lower Bound는 찾고자 하는 값 이상이 처음 나타나는 위치를 return.
// Lower_Bound는 탐색에 O(log N)

// 이 방법의 경우 결과로 나타나는 배열이 존재하는데
// 이 배열이 LIS 배열을 나타내지는 않는다.
// LIS 배열을 만드려면 따로 추가 작업 필요.



// [Lower Bound의 구현 방법]

// 실제로는 만들기가 번거로워 STL <algorithm> 를 사용한다.
// std::lower_bound(A, A+n, k, [compare]
// ex) auto it = lower_bound

// start, end : 배열의 index
int Lower_Bound(int* arr, int start, int size, int target) {
	int center, end;
	end = size-1;	// 이 경우 배열의 인덱스가 아니라 크기
	while (end - start > 0) {
		center = (start + end) / 2;	
		// 1 2 3 4 5	/4
		// 									
		if (arr[center] < target) start = center + 1;
		else end = center;
	}
	return end ;
}

int Lower_Bound2(int a[], int target, int size) {
	int mid, start, end;
	start = 0; end = size - 1;
	while (end > start) {	// end값이 start보다 같거나 작아지면, 종료.
		mid = (start + end) / 2;
		
		if (a[mid] >= target) end = mid;
		else start = mid + 1;
	}
	return end;
}



// [LIS에서 LowerBound가 갖는 의미와, LIS 알고리즘 원리]
// tmp 배열은 arr의 원소를 index로 갖는다.
// tmp[i] = 길이 i인 증가하는 부분 수열을 만들 수 있는 마지막 원소 중
//			가장 작은 값
// 1) 현재의 값이 tmp 배열의 마지막 원소보다 클 경우
//		tmp 배열의 뒤에 값을 추가
// 2) 그렇지 않을 경우
//		현재의 값을 tmp 배열에서 lower_bound 한다.
//		(이 값은 현재의 값을 마지막 원소로 하여 만들수 있는 수열의 길이)
//		tmp 배열의 해당 인덱스에 현재의 값을 대입.

int SolveWithLB(int* arr, int arr_length) {
	int res = 0;
	int tmp[100000];
	memset(tmp, 0, sizeof(int) * arr_length);
	tmp[0] = arr[0];
	int len = 1;
	for (int i = 1; i < arr_length; i++) {
		if (tmp[len-1] < arr[i]) {
			tmp[len] = arr[i];	len++;
			continue;
		}
		//tmp[Lower_Bound2(tmp, arr[i], len)] = arr[i];
		tmp[Lower_Bound(tmp, 0, len, arr[i])] = arr[i];
		
	}
	return len;


}
int main() {
	int T, N;
	scanf("%d", &T);
	for (int tc = 1; tc <= T; tc++) {
		scanf("%d", &N);
		int arr[100000];
		loop1(n, N){
			scanf("%d", &arr[n]);
		}
		printf("#%d %d\n", tc, SolveWithLB(arr, N));
	}

	return 0;
}

